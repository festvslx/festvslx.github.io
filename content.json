{"meta":{"title":"festvslx","subtitle":null,"description":null,"author":"festvslx","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-07-15T13:07:33.000Z","updated":"2019-07-15T13:08:52.477Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-07-15T06:56:37.000Z","updated":"2019-07-26T13:50:19.051Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"about P{ text-align: center; color: #66B3FF; } ​ 所有无聊的事情都会衍生出很多细节让你觉得它复杂而有趣投入其中而浑然不知其无聊的本质 ​"},{"title":"标签","date":"2019-07-15T06:47:02.000Z","updated":"2019-07-15T07:29:40.302Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android子线程与主线程相互通信","slug":"Android子线程与主线程相互通信","date":"2019-12-23T15:41:11.000Z","updated":"2019-12-23T15:46:19.726Z","comments":true,"path":"2019/12/23/Android子线程与主线程相互通信/","link":"","permalink":"http://yoursite.com/2019/12/23/Android子线程与主线程相互通信/","excerpt":"Android 子线程与主线程之间相互的通信 引言 从Android4.0开始系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetWorkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作阻塞从而出现ANR现象。并且Android中所有耗时的操作都最好到子线程里执行。因此有时候需要向子线程传递参数或者子线程向主线程传递参数。","text":"Android 子线程与主线程之间相互的通信 引言 从Android4.0开始系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetWorkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作阻塞从而出现ANR现象。并且Android中所有耗时的操作都最好到子线程里执行。因此有时候需要向子线程传递参数或者子线程向主线程传递参数。 主线程向子线程传递参数 主线程向子线程传递参数常用的就是构造函数了，创建一个class继承runnable，然后加上构造函数就可以达到传递参数的效果。 android12345678910class newRunnable implements Runnable&#123; private int cs1； public newRunnable(int cs1)&#123; this.cs1 = cs1; &#125; public void run()&#123; //DO work here. &#125;&#125;// new Thread(new newRunnable(cs1)).start(); 子线程向主线程传递参数 子线程向主线程传递参数可以用message，然后创建hander来经行监听，个人认为这个方法比较好理解 android12345678910111213141516171819202122232425Runnable newWorkTask = new Runnable()&#123; publlic void run()&#123; //DO work here,假设要返回一个String str Message msg = new Message(); Bundle data = new Bundle(); data.putString(\"key1\",str); msg.what = 1; msg.setDate(data); handler.sendMessaage(msg); &#125;&#125;Handler handler = new Handler()&#123; public void handleMessage(Message msg)&#123; super.handleMessage(msg); switch(msg.what)&#123; case 1: Bundle bundle = msg.getData(); String str = bundle.getString(\"key1\"); //可以在这里更新UI break; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"线程通信","slug":"Android/线程通信","permalink":"http://yoursite.com/categories/Android/线程通信/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android_Broadcast简单应用","slug":"Android-Broadcast简单应用","date":"2019-12-07T05:59:21.000Z","updated":"2019-12-07T06:20:34.429Z","comments":true,"path":"2019/12/07/Android-Broadcast简单应用/","link":"","permalink":"http://yoursite.com/2019/12/07/Android-Broadcast简单应用/","excerpt":"Android broadcast 简单的使用 什么是broadcast？ android通过广播来实现不同进程间的通信对应于广播（broadcat）还有一个广播接收器（broadcast receiver）每个广播指定了对应的action 、 type等信息，每个接收器根据这些信息来过滤是否自己要接收的广播。","text":"Android broadcast 简单的使用 什么是broadcast？ android通过广播来实现不同进程间的通信对应于广播（broadcat）还有一个广播接收器（broadcast receiver）每个广播指定了对应的action 、 type等信息，每个接收器根据这些信息来过滤是否自己要接收的广播。 broadcast receiver 广播接收器主要分为两种类型：标准广播 和 有序广播 而标准广播的注册方法又有动态注册和静态注册。 动态注册定义广播时首先要有广播123456Intent intent = new Intent();// 创建一个新的intentintent.setAction(\"action1\");// 为intent添加action字段进行标识sendBroadcast(intent);// 发送广播 有广播后没有人接收也没有用啊，所以要有接收器。 123IntentFilter filter = new IntentFilter();filter.addAction(ACTION1);registerReceiver(receiver,filter); receiver的注册中有一个receiver 123456BroadcastReceiver receiver = new BroadcastReceiver() &#123;@Override public void onReceive(Context context, Intent intent) &#123; // 在此处经行接收时的操作 &#125;&#125; 这样就完成了动态注册还有一个比较重要的地方，就是注册使用完后要把广播销毁。所以重写onDestroy方法 1unregisterReceiver(receiver);//加入这一行即可 静态注册在比较高的Android studio里，静态注册十分的严格，而大部分的广播都是可以用动态注册解决的，所以就不写了。懒","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Broadcast","slug":"Android/Broadcast","permalink":"http://yoursite.com/categories/Android/Broadcast/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android初识——Activity","slug":"Android初识——Activity","date":"2019-11-05T13:40:35.000Z","updated":"2019-11-05T14:03:46.635Z","comments":true,"path":"2019/11/05/Android初识——Activity/","link":"","permalink":"http://yoursite.com/2019/11/05/Android初识——Activity/","excerpt":"Android 初识 ——Activity 1. Android的四大组件 活动（activity） 用于表现功能 服务（service）， 后台运行服务，不提供界面呈现 广播接受者（Broadcast Receive） 接收广播 内容提供者（Content Provider） 支持多个应用中存储和读取数据，相当于数据库","text":"Android 初识 ——Activity 1. Android的四大组件 活动（activity） 用于表现功能 服务（service）， 后台运行服务，不提供界面呈现 广播接受者（Broadcast Receive） 接收广播 内容提供者（Content Provider） 支持多个应用中存储和读取数据，相当于数据库 2. ActivityActivity是Android的四大组件之一。是用户操作的可视化界面；它为用户提供了一个完成操作指令的窗口。当我们创建完毕Activity之后，需要调用setContentView()方法来完成界面的显示；以此来为用户提供交互的入口。在Android App 中只要能看见的几乎都要依托于Activity，所以Activity是在开发中使用最频繁的一种组件。 Android应用中每一个Activity都必须要在AndroidManifest.xml配置文件中声明，否则系统将不识别也不执行该Activity。 一个Activity通常就是一个单独的窗口 Activity跳转要靠Intent，数据传输也要靠它，数据传输时也可以把数据放到Bundle里，在放到Intent里(即putExtras(Bundle bundle)方法) 3. 简单的UI组件用法图(Button与Fragment)（个人见解）","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Activity","slug":"Android/Activity","permalink":"http://yoursite.com/categories/Android/Activity/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"leetcode刷题","slug":"leetcode刷题","date":"2019-07-28T13:26:44.000Z","updated":"2019-07-28T13:29:51.435Z","comments":true,"path":"2019/07/28/leetcode刷题/","link":"","permalink":"http://yoursite.com/2019/07/28/leetcode刷题/","excerpt":"leetcode算法题 258.各位相加给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。示例： 123456输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。----------进阶:你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？","text":"leetcode算法题 258.各位相加给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。示例： 123456输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。----------进阶:你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 第一眼看题第一个想到的是循环和递归，毕竟太有规律性了。所以在进阶的地方第一眼卡住了。但是仔细想想还是可以想出来的，各位相加，由于输入的数为十位数，所以满十进一。这个满十进一其实是将十个放到一起，看成了一个，而各位相加则仅仅加的是放到一起的数。所以可以抛弃九个。例如：11，11相加即1+1为2，也就是因为11满了10，抛弃了9，即11-9=2，这就是结果。38则不断的减3个9，38-39=11，而11再次相加为2.其实可以38对9取模即可，因为大于10就就要相加。*但是这样的话会有一种特殊的情况即9的倍数。**9的倍数各位相加应该是9然而这个方法会算到0。在大佬的点拨下知道了一种方法可以统一，即先减1来打破9的倍数，最后再加一即可(num-1)%9+1 235.二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 这题利用搜索二叉树的性质十分容易，想要为节点的祖先，那么一定是再节点的两侧，不可能在一侧，否则就一定不是正确答案，答案就一定在左子树或者右子树里。所以就很容易用一个递归完成，递归的出口是pq节点分布在节点的两侧。 226.翻转一颗二叉树翻转一颗二叉树翻转二叉树仅需利用递归把左右子节点交换即可。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"},{"name":"简单","slug":"leetcode/简单","permalink":"http://yoursite.com/categories/leetcode/简单/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"HTML学习(一)","slug":"HTML学习-一","date":"2019-07-26T13:18:56.000Z","updated":"2019-07-26T13:21:49.840Z","comments":true,"path":"2019/07/26/HTML学习-一/","link":"","permalink":"http://yoursite.com/2019/07/26/HTML学习-一/","excerpt":"HTML学习(一) 什么是 HTML？HTML 是用来描述网页的一种标准标记语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页","text":"HTML学习(一) 什么是 HTML？HTML 是用来描述网页的一种标准标记语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 标签介绍HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词，比如 HTML 标签通常是成对出现的，比如 和 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 HTML 文档 与 之间的文本描述网页 与 之间的文本是可见的页面内容 与 标签用于定义文档的头部，它是所有头部元素的容器。 例子： 12345678910&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;文档的标题(&lt;title&gt; 是 head 部分中唯一必需的标签。)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文档的内容...... &lt;!--用来在源文档中插入注释。注释不会在浏览器中显示。--&gt; &lt;/body&gt;&lt;/html&gt; 注意&lt;!DOCTYPE&gt; 声明不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。 HTML 注释12345&lt;!--[if IE 8]&gt; .... 这是条件注释，注意： 条件注释定义只针对 IE 浏览器。 ....&lt;![endif]--&gt;&lt;!--用来在源文档中插入注释。注释不会在浏览器中显示。--&gt; HTML 标签 标签 含义 a 标签用于定义超链接，可以让用户从一个网页跳转到另一个网页。 abbr 用来表示一个缩写词或者首字母缩略词 br 标签用于插入一个简单的换行符。&lt;br /&gt; h1~h6 可定义标题。 hr 标签用于在 HTML 页面中创建一条水平分隔线。 meta 标签用于描述页面内容，关键词，作者，最新修订时间以及其它元信息。教程链接 p 用于定义一个段落，p 元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，你也可以通过样式表进行约束。 style 用于为 HTML 文档定义样式信息。 title 标签用于定义文档的标题。 &lt;a href=&quot;https://www.runoob.com/tags/tag-a.html&quot;&gt;HTML 教程&lt;/a&gt;效果：HTML 教程 &lt;abbr title=&quot;World Health Organization&quot;&gt;WHO&lt;/abbr&gt;效果：WHO 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;title&lt;/title&gt; &lt;style type=\"text/css\"&gt; h1 &#123;color: red&#125; p &#123;color: blue&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;header 1&lt;/h1&gt; &lt;p&gt;A paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"},{"name":"基础","slug":"HTML/基础","permalink":"http://yoursite.com/categories/HTML/基础/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Java基础学习(四)","slug":"Java基础学习-四","date":"2019-07-24T12:30:03.000Z","updated":"2019-07-24T13:38:59.701Z","comments":true,"path":"2019/07/24/Java基础学习-四/","link":"","permalink":"http://yoursite.com/2019/07/24/Java基础学习-四/","excerpt":"Java类 类的声明定义类可以看成是创建Java对象的模板。 1234class name&#123; //类的成员变量 //类的方法&#125;","text":"Java类 类的声明定义类可以看成是创建Java对象的模板。 1234class name&#123; //类的成员变量 //类的方法&#125; 通过下面一个简单的类来理解下Java中类的定义： 1234567class Person&#123; int age; String name; void talk()&#123; System.out.println(\"I am \" + name +\", \" + age + \" years old\"); &#125;&#125; 对象的声明classname name = new classname() 例如 1Person p = new Person(); 这个过程是在栈内声明对象p，并且在堆里开辟空间，把堆内开辟的空间引用赋予p。 对象成员的访问方法为：对象名.方法（属性） 1234Person p = new Person();p.age = 20;p.name = \"小明\";p.talk(); 构造方法的重载Java中同一个类中的2个或2个以上的方法可以一同一个名字，只是它们的参数声明不同即可，在这种情况下，该方法就被称为重载，这个过程称为方法重载。 12345678910class Person&#123; int age; String name; void talk()&#123; System.out.println(\"I am \" + name +\", \" + age + \" years old\"); &#125; void talk(String name)&#123; System.out.println(\"I am \" + name); &#125;&#125; 在实例里talk方法的参数不同，得到的结果也不同。 构造方法的私有方法依实际需要，可以分为public和private。同样，构造方法也有public和private之分。如果设为private，那么就无法在所在类之外的地方调用。 类的封装什么是类的封装？先看实例： 123456789101112131415class Person&#123; int age; String name; void talk()&#123; System.out.println(\"I am \" + name +\", \" + age + \" years old\"); &#125;&#125;public class text &#123; public static void main(String[] args) &#123; Person a = new Person(); a.age = -19; a.name = \"小明\"; a.talk(); &#125;&#125; 从结果可以看出这明显是个不合理的数据，所以为了避免错误得到发生，往往要把类的属性封装(private)，但是上面的代码对属性封装后程序运行出现了错误，因为age和name不可见。那么我们如何给对象赋值呢？开发者会增加setxxx(), getxxx()这样的公有方法来解决。 12345678910111213141516171819202122class Person&#123; private int age; private String name; void talk()&#123; System.out.println(\"I am \" + name +\", \" + age + \" years old\"); &#125; void setAge(int ages)&#123; if(0 &lt; ages) &amp;&amp; (ages &lt; 119) age = ages; &#125; void setName(String str)&#123; name = str; &#125;&#125;public class text &#123; public static void main(String[] args) &#123; Person a = new Person(); a.setName(\"小明\")； a.setAge(19); a.talk(); &#125;&#125; 类的继承继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。class 子类名 extends 父类Java继承只能直接继承父类的公有属性和方法，隐含的继承了私有属性和方法。 1234class 父类&#123;&#125;class 子类 extends 父类&#123;&#125; 实例 1234567class person&#123; int age; String name;&#125;class student extends person&#123; int schoolID;&#125; student有三个属性：age，name，schoolID；而不是一个。java中不允许一个子类继承多个父类（一个人有好几个爸妈你说行吗(っ*´Д`)っ）但是允许多继承（你爷爷有了你爸，你爸有了你，你有了。。。(≧∇≦)ﾉ） 参考文献https://www.runoob.com《Java从入门到精通》","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://yoursite.com/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java对象创建问题","slug":"Java对象创建问题","date":"2019-07-20T06:20:54.000Z","updated":"2019-07-20T07:40:40.827Z","comments":true,"path":"2019/07/20/Java对象创建问题/","link":"","permalink":"http://yoursite.com/2019/07/20/Java对象创建问题/","excerpt":"对象的创建问题在Java中字符串的创建有两种方法 12String s1 = new String(\"abc\"); //第一种String s = \"abc\"; //第二种 第一种new时，java会去常量池里查找是否有abc，如果没有就就在堆中创建一，有的话就会把堆中的对象指向常量池的abc，在把栈里的s指向堆里的对象(该对象指向池里查里的abc)。 第二种时，Java会在字符串池里查找有没有abc这个对象，有就返回对象的引用，没有就先创建这个对象，然后把该对象加入字符串池里，再返回该对象的引用。(字符串池由String类私有的维护)","text":"对象的创建问题在Java中字符串的创建有两种方法 12String s1 = new String(\"abc\"); //第一种String s = \"abc\"; //第二种 第一种new时，java会去常量池里查找是否有abc，如果没有就就在堆中创建一，有的话就会把堆中的对象指向常量池的abc，在把栈里的s指向堆里的对象(该对象指向池里查里的abc)。 第二种时，Java会在字符串池里查找有没有abc这个对象，有就返回对象的引用，没有就先创建这个对象，然后把该对象加入字符串池里，再返回该对象的引用。(字符串池由String类私有的维护) 所以当new方法时，如果常量池里没有“abc”就会产生两个对象，有就产生一个。 字符串连接问题12345678//问题一：String s1 = \"abc\";String s2 = \"a\" + \"bc\";System.out.println(s1 == s2);//问题二：String s3 = \"a\";String s4 = s3 + \"bc\";System.out.println(s4 == s1); 在上面两个问题里，第一个是true；第二个是false。s2 = “a”+”bc”会在常量池里查找“abc”的字符串对象，所以s2会引用s1的abc对象。所以s1会等于s2.s4 = s3+“bc”因为有一个变量，所以涉及到变量的相加，相加时会产生一个新对象。所以不会相等。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://yoursite.com/categories/Java/进阶/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java栈堆常量池","slug":"Java栈堆常量池","date":"2019-07-20T06:00:45.000Z","updated":"2019-07-20T06:19:54.499Z","comments":true,"path":"2019/07/20/Java栈堆常量池/","link":"","permalink":"http://yoursite.com/2019/07/20/Java栈堆常量池/","excerpt":"","text":"栈堆和常量池（浅） JVM栈栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中 。 堆存储的全部是对象，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。一般来说就是new出来的对象。 常量池常量池在方法区里，是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。 我在看new 和不用new时创建了几个对象时看到的这几个概念，我先记录下来，有能力再去深入。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"进阶","slug":"Java/进阶","permalink":"http://yoursite.com/categories/Java/进阶/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"休克","slug":"休克","date":"2019-07-20T05:47:37.000Z","updated":"2019-07-20T05:49:21.087Z","comments":true,"path":"2019/07/20/休克/","link":"","permalink":"http://yoursite.com/2019/07/20/休克/","excerpt":"","text":"休克 18号时身体不舒服，一天都躺家里，也不想去医院，结果19号时病情加重，高烧了39度多。晚上就去了医院，生病了我有不想吃什么东西，结果输液时就因为我空腹导致了我休克。当时，我记得护士刚刚把针插上不到1分钟，我就感觉头晕，胸闷，想吐，我立马和医生说我不舒服（县级医院，晚上就几个医生值班，所以就在门口输液，旁边还有一张床，就两三步）医生赶过来就把我扶到旁边的床上休息结果我屁股还没坐上就晕过去了（医生扶我的时候我就几乎没什么意识了，因为我没有我走路的记忆），身体直挺挺的倒下去，万幸我头撞到墙上醒了过来（当时我还以为是护士把我拍醒的）。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/categories/杂谈/"}],"tags":[]},{"title":"Java基础学习(三)","slug":"Java基础学习-三","date":"2019-07-19T08:38:07.000Z","updated":"2019-07-19T08:40:07.810Z","comments":true,"path":"2019/07/19/Java基础学习-三/","link":"","permalink":"http://yoursite.com/2019/07/19/Java基础学习-三/","excerpt":"Java基础学习(三) 数组什么是数组数组是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来唯一确定数组中的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。 数组的初始化数据类型[] name = new 数据类型[长度]Java数组和C语言的数组差不多，但是功能更强大。Java的数组每个元素都有默认值，默认值取决于数据类型。Java数组有.length方法直接查看数组长度。","text":"Java基础学习(三) 数组什么是数组数组是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来唯一确定数组中的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。 数组的初始化数据类型[] name = new 数据类型[长度]Java数组和C语言的数组差不多，但是功能更强大。Java的数组每个元素都有默认值，默认值取决于数据类型。Java数组有.length方法直接查看数组长度。 1234567891011121314151617181920public class text &#123; public static void main(String[] args) &#123; int [][] a = new int [3][3]; a[0][0] = 1; a[1][1] = 2; a[2][2] = 3; arr_print(a); &#125; public static void arr_print(int[][] a)&#123; for(int i = 0; i &lt; a.length; i++) &#123; for(int j = 0; j &lt; a[i].length; j++) System.out.print(a[i][j]+\" \"); System.out.println(); &#125; &#125;&#125;运行结果：1 0 0 0 2 0 0 0 3 上面的代码可以看出Java的length方法不仅可以看多少行，还可以看每行多少个。 数组的空间开辟与传递数组的开辟主要是将一片默认值的地址赋值给对象（未初始化）和python一样均是将地址赋值给对象，所以会有下面的结果。 12345678910111213public class text &#123; public static void main(String[] args) &#123; int [] a = new int [3]; a[0] = 1; System.out.println(a[0]); int[] b = a; b[0] = 2; System.out.println(a[0]+\" \"b[0]); &#125;&#125;运行结果：12 2 将b数组的第一个值修改后a数组的第一个值也修改了，因为=传递的是数组的地址。 Java对数组的支持 排序 数字升序排序 1//java.util.Arrays.sort(arrayname) 拷贝 1234//方法一：java.lang.System.arraycopy(object src, int srcPos, object dest, int destPos, int length);//方法二：java.util.Arrays.copyOf(arrayname, length); 对象数组从数组的定义可知，数组是可以存放八大基本数据之外的数据类型，比如类。初始化差不多 12类名 [] 对象数组名 = new 类名[长度]；类名 [] 对象数组名 = new 类名[] &#123;&#125;；","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://yoursite.com/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"未解之谜","slug":"未解之谜","date":"2019-07-17T15:21:47.000Z","updated":"2019-07-17T15:23:24.926Z","comments":true,"path":"2019/07/17/未解之谜/","link":"","permalink":"http://yoursite.com/2019/07/17/未解之谜/","excerpt":"","text":"未解之谜今天eclipse出了问题，说找不到jre。然后我在cmd下输入java，发现没用，所以我去看了看环境变量，按照网上的去改，改了半天发现还是没用，就改了回去，绝望中在cmd下输入了java，竟然有用了。。。。。。。。。eclipse的问题也找到了，我安装的32为jdk，eclipse用的64位。我清晰的记得我下载eclipse后还写了个helloworld，并且运行成功了。（菜）。。。。。。。。。。。(=′ー`)现在却变成了这样，我肯定我没改jdk，现在却变了。(＠_＠;)","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/categories/杂谈/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"}]},{"title":"Java基础学习(二)","slug":"Java基础学习-二","date":"2019-07-17T15:09:22.000Z","updated":"2019-07-19T08:41:24.389Z","comments":true,"path":"2019/07/17/Java基础学习-二/","link":"","permalink":"http://yoursite.com/2019/07/17/Java基础学习-二/","excerpt":"Java基础学习(二) Java字符串Java中字符串属于对象，有专门的String类来创建和操作字符串。当然Java中也有字符数组，和C语言一样。String对象和其他对象一样，用关键字进行创建操作。 1234567public class Strings&#123; public static void main(String args[])&#123; char[] hello = &#123; 'h', 'e', 'l', 'l', 'o'&#125;; String hellos = new String(hello); System.out.println( hellos ); &#125;&#125;","text":"Java基础学习(二) Java字符串Java中字符串属于对象，有专门的String类来创建和操作字符串。当然Java中也有字符数组，和C语言一样。String对象和其他对象一样，用关键字进行创建操作。 1234567public class Strings&#123; public static void main(String args[])&#123; char[] hello = &#123; 'h', 'e', 'l', 'l', 'o'&#125;; String hellos = new String(hello); System.out.println( hellos ); &#125;&#125; 当然Java也提供了一些方法来让字符数组与字符串相互转换。使用String.valueOf()将字符数组转换成字符串 12char [] a = &#123;\"h\",\"e\",\"l\",\"l\",\"o\"&#125;;String s = String.valueOf(a); 使用.toCharArray()将字符串转换成字符数组 12String s = \"hello\";char[] a = s.toCharArray(); 注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了. 字符串长度String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。 1234567public class Strings&#123; public static void main(String args[])&#123; String s = \"helloworld\"; int lens = s.length(); System.out.println(\"长度为：\"lens); &#125;&#125; 字符串的连接字符串的连接有两种方法 .concat() 语法如下 12345678910string1.concat(string2)//例子：public class stringadd&#123; public static void main(String args[])&#123; String s = \"hello\"; s = s.concat(\"world!\"); System.out.println(s); &#125;&#125;//输出： helloworld! + 操作符12//直接加起来就好，和python一样，代码。。。被吃了(躺)。//+操作符的功能很强大，可以把任何类型数据连接起来，不局限于字符串。 注意：这两种方法还是有区别的。 字符串还有很多方法，这里就说了重要的几点，其他就不一一赘述了。 Java StringBuffer 和 StringBuilder 类上面记录了String创建后就不可以改变的性质，但是我们常常需要对字符串进行修改，这时就要上面的类了。*StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象，StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 (摘自www.runoob.com) *","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://yoursite.com/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java基础学习(一)","slug":"Java基础学习-一","date":"2019-07-16T15:21:01.000Z","updated":"2019-07-16T15:28:15.697Z","comments":true,"path":"2019/07/16/Java基础学习-一/","link":"","permalink":"http://yoursite.com/2019/07/16/Java基础学习-一/","excerpt":"Java基础学习（一） 1. Java的八大基本数据类型 byte 8位，有符号。 short 16位，有符号。 int 32位，有符号。","text":"Java基础学习（一） 1. Java的八大基本数据类型 byte 8位，有符号。 short 16位，有符号。 int 32位，有符号。 long 64位，有符号，数字后L。 float 单精度，32位，不能表示精确的值（数字后有f） double 双精度，64位，不能表示精确的值（数字后有d） boolean 1位，仅true和false，默认为false char 单一的 16 位 Unicode 字符。 注意：数值类型的基本类型的取值范围都已经以常量的形式定义在对应的包装类中了，无需记忆。 2. 运算符 操作符 描述 ＆ 如果相对应位都是1，则结果为1，否则为0 | 如果相对应位都是0，则结果为0，否则为1 ^ 如果相对应位值相同，则结果为0，否则为1 ~ 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 &amp;&amp; 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 || 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 ! 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 短路逻辑运算符当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。 非短路逻辑运算符非短路运算符不管第一个表达式是否可以得出最后结果,都要对第二个表达式进行判断. 所以 短路运算符只能用于逻辑表达式内，非短路运算符可用于位表达式和逻辑表达式内。也可以说：短路运算只能操作布尔型的，而非短路运算不仅可以操作布尔型，而且可以操作数值型。 也可以看出短路运算符的效率更高。 3. 循环java的循环选择结构和C语言相似，但是也有不一样的地方。 for循环的加强Java5 引入了一种主要用于数组的增强型 for 循环。Java 增强 for 循环语法格式如下: 1234for(声明语句 : 表达式)&#123; //代码句子&#125; 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环* 语句块，其值与此时数组元素的值相等。表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 1234567891011121314部分代码例子1：int [] numbers = &#123;1, 2, 3, 4, 5&#125;; for(int x : numbers )&#123; System.out.print( x + \",\"); &#125;运行结果： 1,2,3,4,5,部分代码例子2：String [] n =&#123;\"n\", \"a\", \"m\", \"e\"&#125;; for( String n : n ) &#123; System.out.print( n + \",\"); &#125;运行结果： n,a,m,e, Java在这方面的加强有点类似python的for语句的用法。 4. 参考文献https://www.runoob.com","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://yoursite.com/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"markdown基本语法","slug":"markdown基本语法","date":"2019-07-15T02:56:49.000Z","updated":"2019-07-19T08:41:40.708Z","comments":true,"path":"2019/07/15/markdown基本语法/","link":"","permalink":"http://yoursite.com/2019/07/15/markdown基本语法/","excerpt":"markdown 基本教程 第一次使用markdown，所以去找了找资料，把一些基本的用法记录下来，供以后查看。","text":"markdown 基本教程 第一次使用markdown，所以去找了找资料，把一些基本的用法记录下来，供以后查看。 1. 标题 在markdown中几级标题就在前方加#符号即可，注意要有空格。 # 这是一级标题 ## 这是二级标题 ### 这是三级标题2. 换行 段落的换行是使用两个以上空格加上回车。 3. 字体 加粗 要加粗的在加粗部分前后用两个*号包起来。 斜体 要变斜体的用一个*号包起来。 斜体加粗 要斜体加粗的用三个*号包起来。 删除线 要删除线在前后用两个~~包起来。1234**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 4. 代码块 一段代码可以用反引号包起来表示 代码前加上制表符或者4个空格即可表示代码区块 也可以用3个反引号来表示一个区域的代码块12345`print(&quot;hello world!&quot;)`(```)代码。。。。(```)注意这个括号没有只是为了防止转译 5. 区块 Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： 12&gt;区块内容&gt;区块内容 6. 链接 链接的用法是 -&gt;[链接名称](链接地址) 7. 图片 图片的用法如下 12![alt 属性文本](图片地址 &quot;可选标题&quot;)其中alt属性文本就是图片下面的文字，相当于图片的解释 8. 列表8.1 有序列表 有序列表直接用数字加上.号表示（有空格）8.2 无序列表 无序列表使用星号*、加号+或是减号-作为列表标记：8.3 嵌套列表 嵌套列表只需在子列表前加4个空格。 9. 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用-来分隔表头和其他行。 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 效果如下：| 表头 | 表头 || —— | —— || 单元格 | 单元格 || 单元格 | 单元格 | 10. 参考文献https://www.runoob.com/markdown/md-tutorial.htmlmarkdown还支持HTML元素，数学公式等等，这里就不谈了。","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"hexo+GitHub","slug":"hexo-GitHub","date":"2019-07-14T08:58:17.000Z","updated":"2019-07-15T13:11:28.021Z","comments":true,"path":"2019/07/14/hexo-GitHub/","link":"","permalink":"http://yoursite.com/2019/07/14/hexo-GitHub/","excerpt":"hexo + github 搭建准备1. 下载node.js 和 git 2. 在cmd或者git bash下安装hexo [npm install -g hexo] 3. 安装好后即可初始化了，[hexo init (folder)]","text":"hexo + github 搭建准备1. 下载node.js 和 git 2. 在cmd或者git bash下安装hexo [npm install -g hexo] 3. 安装好后即可初始化了，[hexo init (folder)] 主题更改​ 主题可以去网上搜索网上资源很多。 GitHub准备1. 首先要有GitHub账号(废话)创建一个仓库，仓库名字有规范的必须是(账号名).github.io2. 配置ssh keyssh key可以在git bash下输入ssh-keygen.exe，然后不断按回车。。。 一般公钥在c盘user里的.ssh文件夹里id_rsa.pub是公钥，id_rsa是私钥。 把公钥放到GitHub里就好。3. 配置文件配置_config.yml中有关deploy的部分改为下面即可 deploy: type: git repository: git@github.com:(账号名)/(账号名).github.io.git branch: master 上传上传前先安装一个插件 在git 下输入 npm install hexo-deployer-git --save 然后就可以输入hexo d上传到GitHub上了 参考文献www.codesheep.com","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]}]}